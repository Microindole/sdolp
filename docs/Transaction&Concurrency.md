# 模块四详解 · 事务与并发控制 (Transaction & Concurrency)

## 1. 模块概述

事务与并发控制模块是 MiniDB 数据库的稳定核心，是实现**ACID**特性的直接保障。ACID（原子性、一致性、隔离性、持久性）是衡量一个关系型数据库是否可靠的关键标准。本模块通过一系列精密协作的组件，确保了即使在多用户并发访问和系统意外崩溃的情况下，数据也能保持正确和一致。

- **原子性 (Atomicity)**: 事务被视为一个不可分割的工作单元，其所有操作要么全部成功，要么全部失败回滚，数据库不会停留在中间状态。
- **一致性 (Consistency)**: 保证事务将数据库从一个有效状态转变为另一个有效状态。这是通过原子性、隔离性和数据库自身的约束（如主键）共同保障的。
- **隔离性 (Isolation)**: 确保并发执行的多个事务之间互不干扰。一个事务的中间状态对其他事务是不可见的，使得每个事务都感觉像是在独立地操作数据库。
- **持久性 (Durability)**: 一旦事务被成功提交，其结果就是永久性的，即使系统随后发生崩溃，数据也不会丢失。

**核心职责**:

- 管理事务的生命周期（开始、提交、中止）。
- 通过**预写日志 (Write-Ahead Logging, WAL)** 机制保障操作的原子性和持久性。
- 通过**页级锁**机制实现并发事务的隔离。
- 通过**ARIES恢复算法**在数据库启动时进行崩溃恢复，确保数据的一致性。

## 2. 总体架构与数据流

本模块由四个高度协同的组件构成，它们共同协作以实现ACID特性。

**架构与交互图**:

```
+--------------------------------+
|       执行引擎 (Executor)       |
+--------------------------------+
    |
    | 1. begin(), commit(), abort()
    V
+--------------------------------+
|  事务管理器 (TransactionManager) |
+--------------------------------+
    |         |               |
    | 2. lock |         3. log|
    |         |               |
    V         V               V
+-------------+   +-------------------+
| 锁管理器     |   | 日志管理器 (WAL)    |
| (LockManager) |   | (LogManager)      |
+-------------+   +-------------------+
                          |
                          | 4. crash & restart
                          V
                 +-------------------+
                 | 恢复管理器 (ARIES)  |
                 | (RecoveryManager) |
                 +-------------------+
```

**流程详解**:

1. **事务生命周期**: **执行引擎**中的DML执行器在开始操作前，会向 `TransactionManager` 请求开启一个新事务 (`begin()`)。操作成功后调用 `commit()`，失败则调用 `abort()`。
2. **加锁**: 在事务执行期间，当任何执行器需要访问（读/写）一个数据页时，它必须先向 `LockManager` 请求相应模式（共享/排他）的锁。如果锁冲突，当前事务将被阻塞，直到锁被释放。
3. **记录日志**: 在对一个数据页进行**任何修改之前**，执行器必须先构造一条包含修改前后信息的**日志记录 (`LogRecord`)**，并通过 `LogManager` 将其**持久化**到磁盘上的日志文件中。这是**预写日志 (WAL)** 的核心原则。
4. **崩溃恢复**: 当数据库启动时，`RecoveryManager` 会被自动调用。它会读取日志文件，并严格按照**ARIES**协议的三个阶段（分析、重做、撤销）来恢复数据库，确保所有已提交的事务被重做，所有未完成的事务被撤销。

## 3. 核心组件详解

### 3.1 事务管理器 (`TransactionManager`)

- **职责**: 抽象并管理事务的生命周期。
- **核心类**: `transaction.Transaction`, `transaction.TransactionManager`
- **实现细节**:
  - `Transaction` 对象: 作为一个状态容器，封装了事务的唯一ID (`transactionId`)、当前状态 (`State` enum: `ACTIVE`, `COMMITTED`, `ABORTED`)、该事务所持有的锁列表，以及指向其上一条日志的**日志序列号 (LSN)**。
  - `begin()`: 创建一个新的 `Transaction` 实例，并立即写入一条 `BEGIN` 类型的日志记录。
  - `commit()`:
    1. 写入一条 `COMMIT` 类型的日志记录并**强制刷盘**。
    2. 释放该事务持有的所有锁。
    3. 将事务状态置为 `COMMITTED`。
  - `abort()`:
    1. 写入一条 `ABORT` 类型的日志记录。
    2. 释放所有锁。
    3. 将事务状态置为 `ABORTED`。（注意：物理数据的回滚由 `RecoveryManager` 在崩溃恢复时统一处理）。

### 3.2 日志管理器 (`LogManager` & WAL)

- **职责**: 实现预写日志（WAL）协议，为原子性和持久性提供保障。
- **核心类**: `transaction.log.LogManager`, `transaction.log.LogRecord`
- **实现细节**:
  - **WAL协议**: 核心原则是 **“日志先行”**。在修改任何一个数据页并将其写回磁盘**之前**，描述该修改的日志记录**必须**先被写入到磁盘上的日志文件中。
  - `LogRecord`: 日志记录是恢复的基本单位。它被设计为可序列化的对象，包含：
    - `LSN`: 日志序列号，即该日志在日志文件中的物理偏移量，是日志记录的唯一标识。
    - `transactionId`: 所属的事务ID。
    - `prevLSN`: 指向同一事务的上一条日志记录，形成一个反向链表，便于回滚。
    - `LogType`: 日志类型，如 `INSERT`, `UPDATE`, `DELETE`, `COMMIT`, `CLR` (补偿日志) 等。
    - `Payload`: 日志的具体内容，如 `UPDATE` 日志会包含修改前（before-image）和修改后（after-image）的元组数据。
  - `appendLogRecord()`: 这是一个**同步方法**，确保日志的顺序写入。在将日志写入文件后，会立即调用 `logFile.getFD().sync()` 来强制将操作系统的文件缓存刷入物理磁盘，这是**实现持久性 (Durability) 的关键**。

### 3.3 锁管理器 (`LockManager`)

- **职责**: 提供页级并发控制，保障事务的隔离性 (Isolation)。
- **核心类**: `transaction.LockManager`
- **实现细节**:
  - **锁粒度**: 实现了**页级锁 (Page-Level Locking)**。
  - **锁模式**: 支持两种锁模式：
    - **共享锁 (Shared Lock, S-Lock)**: 用于读操作。多个事务可以同时持有一个页的S-Lock。
    - **排他锁 (Exclusive Lock, X-Lock)**: 用于写操作。一个事务持有X-Lock时，其他任何事务都不能再获取该页的任何锁。
  - **锁表 (`lockTable`)**: 内部使用一个 `ConcurrentHashMap` 作为锁表，将 `PageId` 映射到一个 `LockRequestQueue` 对象。
  - **锁请求队列**: `LockRequestQueue` 包含一个请求列表和 `ReentrantLock`/`Condition`，用于处理锁的等待和唤醒。
  - **加锁 (`lockShared`/`lockExclusive`)**:
    1. 一个事务的加锁请求会被封装成 `LockRequest` 并加入对应页的请求队列。
    2. 检查该请求是否与队列中**已被授予**的锁兼容。
    3. 如果不兼容，当前线程会调用 `condition.await()` 进入等待状态。
  - **解锁 (`unlock`)**: 当一个事务提交或中止时，它会释放其持有的所有锁。解锁操作会从请求队列中移除对应的 `LockRequest`，并调用 `condition.signalAll()` 来唤醒所有等待在该页上的其他事务，让它们重新竞争锁。

### 3.4 恢复管理器 (`RecoveryManager` & ARIES)

- **职责**: 实现ARIES恢复算法，在数据库启动时自动运行，以应对系统崩溃。

- **核心类**: `transaction.RecoveryManager`

- **实现细节**: 严格遵循ARIES的三个阶段：

  1. **分析阶段 (Analysis)**:
     - 从头开始扫描整个日志文件。
     - 重建**活动事务表 (Active Transaction Table, ATT)**，记录在崩溃时哪些事务尚未提交或中止。
     - （在本项目中，为了简化，没有显式构建脏页表，而是通过重做所有日志来达到同样效果）。
  2. **重做阶段 (Redo)**:
     - 再次从头开始正向扫描日志。
     - **无条件地重做 (redo)** 日志中记录的所有物理操作（`INSERT`, `UPDATE`, `DELETE`），无论其所属事务最终是提交还是中止。
     - 此阶段完成后，数据库的状态将恢复到**崩溃发生的确切瞬间**。所有已写入日志但可能未写入数据文件的修改都被恢复了。

  - **撤销阶段 (Undo)**:
    - 对于在分析阶段被确定为“失败者”（即在ATT中）的事务，从其**最后一条日志记录**开始，沿着 `prevLSN` 链反向扫描。
    - 对每一条修改操作日志，执行其**逆操作**（如 `INSERT` 的逆操作是 `DELETE`）。
    - 每执行一次逆操作，就写入一条特殊的**补偿日志记录 (Compensation Log Record, CLR)**。CLR 指向下一个要撤销的日志（`undoNextLSN`），并且它自身**不需要被撤销**。这保证了即使在恢复过程中再次崩溃，恢复过程也能正确地从断点继续，实现了**幂等性**。
    - 当一个失败事务的所有操作都被撤销后，为其写入一条 `ABORT` 日志，标志着该事务的回滚正式完成。

## 4. 与其他模块的交互

- **与执行引擎 (Execution Engine)**: 事务模块是执行引擎运行的基础。所有DML和数据访问执行器都在一个 `Transaction` 上下文中操作，通过本模块的组件来保证ACID。
- **与存储引擎 (Storage Engine)**:
  - `LogManager` 依赖 `DiskManager` 来读写日志文件。
  - `LockManager` 管理的对象是 `PageId`，这是存储引擎的基本单位。
  - `RecoveryManager` 在Redo/Undo阶段会直接通过 `BufferPoolManager` 来获取和修改数据页。