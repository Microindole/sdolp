# 模块三详解 · 存储引擎 (Storage Engine)

## 1. 模块概述

存储引擎是 MiniDB 数据库内核的物理基础，是整个系统的“基石”。它负责管理数据在易失性内存（RAM）和持久化存储（磁盘）之间的所有交互。从上层模块（如执行引擎、事务管理器）来看，存储引擎提供了一套抽象、高效的数据访问接口，将它们与底层复杂的文件I/O、内存管理和数据布局细节完全隔离。

本模块的设计目标是实现一个高效、可扩展且可靠的存储层，其性能直接关系到整个数据库的吞吐量和响应时间。它由多个紧密协作的子组件构成，共同完成数据的持久化存储和快速检索。

**核心职责**:

- 提供对磁盘上数据文件的底层读写抽象。
- 在内存中实现一个缓冲池，以减少昂贵的磁盘I/O操作。
- 定义数据在磁盘页中的物理组织方式（页面布局）。
- 实现高性能的B+树索引结构，以加速数据检索。

## 2. 总体架构与层次

存储引擎本身采用分层设计，每一层都建立在更底层提供的抽象之上，职责清晰。

**架构层次图**:

```
+----------------------------------+
|      上层模块 (执行引擎, 事务等)      |
+----------------------------------+
             ^
             | (通过 TableHeap, BPlusTree 访问)
+----------------------------------+
|  3. 数据组织与访问层 (Data Org)  |
|   - B+树索引 (BPlusTree)        |
|   - 页面布局 (Slotted Page)     |
+----------------------------------+
             ^
             | (请求/获取 Page 对象)
+----------------------------------+
|  2. 内存缓冲层 (Buffering)       |
|   - 缓冲池管理器 (BufferPoolManager)|
|   - 页面替换策略 (LRU, Clock...)  |
+----------------------------------+
             ^
             | (读/写物理页)
+----------------------------------+
|  1. 物理存储层 (Physical I/O)    |
|   - 磁盘管理器 (DiskManager)     |
+----------------------------------+
             ^
             | (Java I/O)
+----------------------------------+
|      文件系统 (minidb.data)      |
+----------------------------------+
```

**层次详解**:

1. **物理存储层 (`DiskManager`)**: 最底层，直接与文件系统交互。它将整个数据库文件视为一个由定长**页 (Page)** 组成的数组，并负责页的分配、释放、读取和写入。
2. **内存缓冲层 (`BufferPoolManager`)**: 位于磁盘管理器之上。它在内存中维护一个**缓冲池 (Buffer Pool)**，用于缓存从磁盘读出的页。当上层请求一个页时，它首先检查该页是否已在缓冲池中（“命中”），如果是，则直接返回内存中的页，避免磁盘I/O。如果缓冲池已满，它会根据配置的**页面替换策略**选择一个“受害页”写回磁盘，为新页腾出空间。
3. **数据组织与访问层**: 这一层定义了数据在单个页内的组织方式以及跨页的数据结构。
   - **页面布局 (`Page`)**: 定义了每个页的内部结构，本项目采用**开槽页 (Slotted Page)** 布局来高效地存储和管理可变长度的元组 (`Tuple`)。
   - **B+树索引 (`BPlusTree`)**: 建立在页和缓冲池之上，是一种高效的磁盘数据结构。它将索引的节点（无论是内部节点还是叶子节点）都存储在一个或多个页中，并通过缓冲池管理器进行访问。

## 3. 核心组件详解

### 3.1 磁盘管理器 (`DiskManager`)

- **职责**: 封装所有对数据库文件 (`.db`) 的底层读写操作。
- **核心类**: `storage.disk.DiskManager`
- **实现细节**:
  - **文件管理**: 将单个数据库文件（如 `minidb.data`）抽象为一个巨大的字节数组。
  - **页的抽象**: 提供了以**页 (`Page`)** 为单位的I/O接口，隐藏了文件偏移量的计算细节。
  - **页分配与回收**:
    - 维护一个**空闲列表 (Free List)** 来管理被删除的页。这个列表是一个简单的链表结构，其头指针持久化在数据库文件的文件头中。
    - 当请求分配新页 (`allocatePage`) 时，优先从空闲列表中取用。如果空闲列表为空，则在文件末尾追加新的空间。
    - `deallocatePage` 会将被释放的页添加到空闲列表的头部。

### 3.2 页面布局 (`Page`)

- **职责**: 定义数据页的内存表示和物理布局。
- **核心类**: `storage.page.Page`, `storage.page.PageId`
- **实现细节**:
  - **固定大小**: 每个 `Page` 对象在内存中都由一个固定大小（本项目为4096字节）的 `ByteBuffer` 表示。
  - **开槽页 (Slotted Page) 布局**:
    - **页头 (Header)**: 存储元数据，如页内元组的数量、空闲空间起始指针、以及指向下一个数据页的 `PageId`（用于实现表数据的链式存储）。
    - **槽数组 (Slot Array)**: 紧跟在页头后面，是一个由定长槽组成的数组。每个槽包含两部分信息：对应元组的起始偏移量和元组的长度。
    - **数据区**: 元组的实际数据从页的末尾向前存储。
    - **优点**: 这种“两头向中间增长”的布局能够高效地存储可变长度的元组，支持快速访问，并且在删除元组后可以方便地进行空间整理。

### 3.3 缓冲池管理器 (`BufferPoolManager`)

- **职责**: 在内存中缓存磁盘页，以加速数据访问。
- **核心类**: `storage.buffer.BufferPoolManager`
- **实现细节**:
  - **页表 (`pageTable`)**: 内部维护一个 `ConcurrentHashMap`，将 `PageId` 映射到内存中的 `Page` 对象。
  - **获取页面 (`getPage`)**:
    - **命中 (Hit)**: 如果请求的 `PageId` 存在于页表中，直接返回对应的 `Page` 对象，并通知页面替换策略该页最近被访问过。
    - **未命中 (Miss)**: 如果 `PageId` 不在页表中，则需要从磁盘加载。此时会检查缓冲池是否已满。
  - **页面淘汰**:
    - 如果缓冲池已满，会调用 `BufferPoolReplacer` 的 `unpin()` 方法选择一个“受害页”进行淘汰。
    - 被淘汰的页如果被修改过（“脏页”），则必须先通过 `DiskManager` 将其写回磁盘。
  - **可插拔的替换策略**: `BufferPoolManager` 通过 `BufferPoolReplacer` 接口支持多种页面替换算法，在构造时指定。
    - `LRUReplacer`: 最近最少使用。
    - `FIFOReplacer`: 先进先出。
    - `ClockReplacer`: 时钟/二次机会算法。
    - `MLFQReplacer`: 多级反馈队列算法。

### 3.4 B+树索引 (`BPlusTree`)

- **职责**: 提供高性能的键值查找、插入和删除功能。
- **核心类**: `storage.index.BPlusTree`, `BPlusTreeInternalPage`, `BPlusTreeLeafPage`
- **实现细节**:
  - **节点即页面**: B+树的每个节点（无论是内部节点还是叶子节点）都存储在一个或多个 `Page` 中。对节点的访问必须通过 `BufferPoolManager` 来完成。
  - **内部节点 (`BPlusTreeInternalPage`)**: 存储 `(key, child_page_id)` 对。键用于路由查找，`child_page_id` 指向下一层的子节点。
  - **叶子节点 (`BPlusTreeLeafPage`)**: 存储 `(key, RID)` 对。`RID` (Record ID) 是一个指向元组在数据页中物理位置的指针（`PageId` + `SlotIndex`）。所有叶子节点通过指针连接成一个双向链表，以支持高效的范围查询。
  - **并发安全**: B+树本身不直接处理并发，并发控制的责任交由上层的**事务管理器**和**锁管理器**，通过对B+树页面加锁来实现。
  - **动态平衡**:
    - **节点分裂**: 当向一个已满的节点插入数据时，该节点会分裂成两个，并将中间的键提升到父节点。
    - **节点合并/重分配**: 当从一个节点删除数据导致其内容过少（低于阈值）时，会尝试从相邻的兄弟节点“借”一些数据（重分配），或者与兄弟节点合并以维持B+树的平衡。

## 4. 与其他模块的交互

- **与执行引擎 (Execution Engine)**: 存储引擎是执行引擎的数据来源。执行器通过`TableHeap`（封装了对数据页的访问）和`BPlusTree`（封装了对索引页的访问）这两个高级接口来与存储引擎交互。
- **与事务与并发控制 (Transaction & Concurrency)**: 存储引擎管理的`Page`是加锁的基本单位。任何对页的访问都必须先通过`LockManager`获取相应的锁。`DiskManager`也为`LogManager`提供服务，用于持久化事务日志。
- **与元数据管理器 (Catalog)**: `Catalog`自身的数据（如表、列的定义）也是存储在`Page`中，并通过存储引擎进行管理。反之，存储引擎在反序列化元组时，需要从`Catalog`获取`Schema`信息。